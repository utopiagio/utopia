package utopia

import (
	"image/color"
	"time"

	"gioui.org/layout"
	"gioui.org/op"
	"gioui.org/widget"
	"gioui.org/widget/material"
)

// Scrim implments a clickable translucent overlay. It can animate appearing
// and disappearing as a fade-in, fade-out transition from zero opacity
// to a fixed maximum opacity.
type GoScrim struct {
	// FinalAlpha is the final opacity of the scrim on a scale from 0 to 255.
	FinalAlpha uint8
	widget.Clickable
}

// Layout draws the scrim using the provided animation. If the animation indicates
// that the scrim is not visible, this is a no-op.
func (s *GoScrim) Layout(gtx layout.Context, th *material.Theme, anim *VisibilityAnimation) layout.Dimensions {
	return s.Clickable.Layout(gtx, func(gtx C) D {
		if !anim.Visible() {
			return layout.Dimensions{}
		}
		gtx.Constraints.Min = gtx.Constraints.Max
		currentAlpha := s.FinalAlpha
		if anim.Animating() {
			revealed := anim.Revealed(gtx)
			currentAlpha = uint8(float32(s.FinalAlpha) * revealed)
		}
		color := th.Fg
		color.A = currentAlpha
		fill := WithAlpha(color, currentAlpha)
		paintRect(gtx, gtx.Constraints.Max, fill)
		return layout.Dimensions{Size: gtx.Constraints.Max}
	})
}

// ScrimState defines persistent state for a scrim.
type GoScrimState struct {
	widget.Clickable
	VisibilityAnimation
}

// ScrimStyle defines how to layout a scrim.
type GoScrimStyle struct {
	*GoScrimState
	Color      color.NRGBA
	FinalAlpha uint8
}

// NewScrim allocates a ScrimStyle.
// Alpha is the final alpha of a fully "appeared" scrim.
func GoModalScrim(th *material.Theme, scrim *GoScrimState, alpha uint8) GoScrimStyle {
	return GoScrimStyle{
		GoScrimState: scrim,
		Color:      th.Fg,
		FinalAlpha: alpha,
	}
}

func (scrim GoScrimStyle) Layout(gtx C) D {
	return scrim.Clickable.Layout(gtx, func(gtx C) D {
		if !scrim.Visible() {
			return D{}
		}
		gtx.Constraints.Min = gtx.Constraints.Max
		alpha := scrim.FinalAlpha
		if scrim.Animating() {
			alpha = uint8(float32(scrim.FinalAlpha) * scrim.Revealed(gtx))
		}
		return Rect{
			Color: WithAlpha(scrim.Color, alpha),
			Size:  gtx.Constraints.Max,
		}.Layout(gtx)
	})
}


// ModalLayer is a widget drawn on top of the normal UI that can be populated
// by other material components with dismissble modal dialogs. For instance,
// the App Bar can render its overflow menu within the modal layer, and the
// modal navigation drawer is entirely within the modal layer.
type GoModalLayerObj struct {
	VisibilityAnimation
	GoScrim
	Widget func(gtx layout.Context, th *material.Theme, anim *VisibilityAnimation) layout.Dimensions
}

const defaultModalAnimationDuration = time.Millisecond * 250

// NewModal creates an initializes a modal layer.
func GoModalLayer() *GoModalLayerObj {
	m := GoModalLayerObj{}
	m.VisibilityAnimation.State = Invisible
	m.VisibilityAnimation.Duration = defaultModalAnimationDuration
	m.GoScrim.FinalAlpha = 82 //default
	return &m
}

// Layout renders the modal layer. Unless a modal widget has been triggered,
// this will do nothing.
func (m *GoModalLayerObj) Layout(gtx layout.Context, th *material.Theme) layout.Dimensions {
	if !m.Visible() {
		return D{}
	}
	if m.GoScrim.Clicked() {
		m.Disappear(gtx.Now)
	}
	scrimDims := m.GoScrim.Layout(gtx, th, &m.VisibilityAnimation)
	if m.Widget != nil {
		_ = m.Widget(gtx, th, &m.VisibilityAnimation)
	}
	return scrimDims
}

// ModalState defines persistent state for a modal.
type GoModalState struct {
	GoScrimState
	// content is the content widget to layout atop a scrim.
	// This is specified as a field because where the content is defined
	// is not where it is invoked.
	// Thus, the content widget becomes the state of the modal.
	content layout.Widget
}

// ModalStyle describes how to layout a modal.
// Modal content is layed centered atop a clickable scrim.
type GoModalStyle struct {
	*GoModalState
	Scrim ScrimStyle
}

// Modal lays out a content widget atop a clickable scrim.
// Clicking the scrim dismisses the modal.
func Modal(th *material.Theme, modal *GoModalState) GoModalStyle {
	return ModalStyle{
		ModalState: modal,
		Scrim:      GoScrim(th, &modal.ScrimState, 250),
	}
}

// Layout the scrim and content. The content is only laid out once
// the scrim is fully animated in, and is hidden on the first frame
// of the scrim's fade-out animation.
func (m GoModalStyle) Layout(gtx C) D {
	if m.content == nil || !m.Visible() {
		return D{}
	}
	if m.Clicked() {
		m.Disappear(gtx.Now)
	}
	macro := op.Record(gtx.Ops)
	dims := layout.Stack{}.Layout(
		gtx,
		layout.Expanded(func(gtx C) D {
			return m.Scrim.Layout(gtx)
		}),
		layout.Expanded(func(gtx C) D {
			if m.Scrim.Visible() && !m.Scrim.Animating() {
				return m.content(gtx)
			}
			return D{}
		}),
	)
	op.Defer(gtx.Ops, macro.Stop())
	return dims
}

// Show widget w in the modal, starting animation at now.
func (m *GoModalState) Show(now time.Time, w layout.Widget) {
	m.content = w
	m.Appear(now)
}